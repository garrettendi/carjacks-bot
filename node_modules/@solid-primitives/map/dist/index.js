import { batch } from "solid-js";
import { TriggerCache } from "@solid-primitives/trigger";
const $OBJECT = Symbol("track-object");
/**
 * A reactive version of `Map` data structure. All the reads (like `get` or `has`) are signals, and all the writes (`delete` or `set`) will cause updates to appropriate signals.
 * @param initial initial entries of the reactive map
 * @param equals signal equals function, determining if a change should cause an update
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/map#ReactiveMap
 * @example
 * const userPoints = new ReactiveMap<User, number>();
 * createEffect(() => {
 *    userPoints.get(user1) // => T: number | undefined (reactive)
 *    userPoints.has(user1) // => T: boolean (reactive)
 *    userPoints.size // => T: number (reactive)
 * });
 * // apply changes
 * userPoints.set(user1, 100);
 * userPoints.delete(user2);
 * userPoints.set(user1, { foo: "bar" });
 */
export class ReactiveMap extends Map {
    #keyTriggers = new TriggerCache();
    #valueTriggers = new TriggerCache();
    [Symbol.iterator]() {
        return this.entries();
    }
    constructor(entries) {
        super();
        if (entries)
            for (const entry of entries)
                super.set(...entry);
    }
    get size() {
        this.#keyTriggers.track($OBJECT);
        return super.size;
    }
    *keys() {
        this.#keyTriggers.track($OBJECT);
        for (const key of super.keys()) {
            yield key;
        }
    }
    *values() {
        this.#valueTriggers.track($OBJECT);
        for (const value of super.values()) {
            yield value;
        }
    }
    *entries() {
        this.#keyTriggers.track($OBJECT);
        this.#valueTriggers.track($OBJECT);
        for (const entry of super.entries()) {
            yield entry;
        }
    }
    forEach(callbackfn, thisArg) {
        this.#keyTriggers.track($OBJECT);
        this.#valueTriggers.track($OBJECT);
        super.forEach(callbackfn, thisArg);
    }
    has(key) {
        this.#keyTriggers.track(key);
        return super.has(key);
    }
    get(key) {
        this.#valueTriggers.track(key);
        return super.get(key);
    }
    set(key, value) {
        const hadNoKey = !super.has(key);
        const hasChanged = super.get(key) !== value;
        const result = super.set(key, value);
        if (hasChanged || hadNoKey) {
            batch(() => {
                if (hadNoKey) {
                    this.#keyTriggers.dirty($OBJECT);
                    this.#keyTriggers.dirty(key);
                }
                if (hasChanged) {
                    this.#valueTriggers.dirty($OBJECT);
                    this.#valueTriggers.dirty(key);
                }
            });
        }
        return result;
    }
    delete(key) {
        const isDefined = super.get(key) !== undefined;
        const result = super.delete(key);
        if (result) {
            batch(() => {
                this.#keyTriggers.dirty($OBJECT);
                this.#valueTriggers.dirty($OBJECT);
                this.#keyTriggers.dirty(key);
                if (isDefined) {
                    this.#valueTriggers.dirty(key);
                }
            });
        }
        return result;
    }
    clear() {
        if (super.size === 0)
            return;
        batch(() => {
            this.#keyTriggers.dirty($OBJECT);
            this.#valueTriggers.dirty($OBJECT);
            for (const key of super.keys()) {
                this.#keyTriggers.dirty(key);
                this.#valueTriggers.dirty(key);
            }
            super.clear();
        });
    }
}
/**
 * A reactive version of `WeakMap` data structure. All the reads (like `get` or `has`) are signals, and all the writes (`delete` or `set`) will cause updates to appropriate signals.
 * @param initial initial entries of the reactive map
 * @param equals signal equals function, determining if a change should cause an update
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/map#ReactiveWeakMap
 * @example
 * const userPoints = new ReactiveWeakMap<User, number>();
 * createEffect(() => {
 *    userPoints.get(user1) // => T: number | undefined (reactive)
 *    userPoints.has(user1) // => T: boolean (reactive)
 * });
 * // apply changes
 * userPoints.set(user1, 100);
 * userPoints.delete(user2);
 * userPoints.set(user1, { foo: "bar" });
 */
export class ReactiveWeakMap extends WeakMap {
    #keyTriggers = new TriggerCache(WeakMap);
    #valueTriggers = new TriggerCache(WeakMap);
    constructor(entries) {
        super();
        if (entries)
            for (const entry of entries)
                super.set(...entry);
    }
    has(key) {
        this.#keyTriggers.track(key);
        return super.has(key);
    }
    get(key) {
        this.#valueTriggers.track(key);
        return super.get(key);
    }
    set(key, value) {
        const hadNoKey = !super.has(key);
        const hasChanged = super.get(key) !== value;
        const result = super.set(key, value);
        if (hasChanged || hadNoKey) {
            batch(() => {
                if (hadNoKey)
                    this.#keyTriggers.dirty(key);
                if (hasChanged)
                    this.#valueTriggers.dirty(key);
            });
        }
        return result;
    }
    delete(key) {
        const isDefined = super.get(key) !== undefined;
        const result = super.delete(key);
        if (result) {
            batch(() => {
                this.#keyTriggers.dirty(key);
                if (isDefined)
                    this.#valueTriggers.dirty(key);
            });
        }
        return result;
    }
}
/** @deprecated */
export function createMap(initial) {
    const map = new ReactiveMap(initial);
    return new Proxy(() => [...map], {
        get: (_, b) => map[b],
    });
}
/** @deprecated */
export function createWeakMap(initial) {
    return new ReactiveWeakMap(initial);
}
