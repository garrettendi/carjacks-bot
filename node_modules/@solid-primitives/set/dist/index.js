import { batch } from "solid-js";
import { TriggerCache } from "@solid-primitives/trigger";
const $KEYS = Symbol("track-keys");
/**
 * A reactive version of a Javascript built-in `Set` class.
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/set#ReactiveSet
 * @example
 * const set = new ReactiveSet([1,2,3]);
 * [...set] // reactive on any change
 * set.has(2) // reactive on change to the result
 * // apply changes
 * set.add(4)
 * set.delete(2)
 * set.clear()
 */
export class ReactiveSet extends Set {
    #triggers = new TriggerCache();
    constructor(values) {
        super();
        if (values)
            for (const value of values)
                super.add(value);
    }
    [Symbol.iterator]() {
        return this.values();
    }
    get size() {
        this.#triggers.track($KEYS);
        return super.size;
    }
    has(value) {
        this.#triggers.track(value);
        return super.has(value);
    }
    keys() {
        return this.values();
    }
    *values() {
        this.#triggers.track($KEYS);
        for (const value of super.values()) {
            yield value;
        }
    }
    *entries() {
        this.#triggers.track($KEYS);
        for (const entry of super.entries()) {
            yield entry;
        }
    }
    forEach(callbackfn, thisArg) {
        this.#triggers.track($KEYS);
        super.forEach(callbackfn, thisArg);
    }
    add(value) {
        if (!super.has(value)) {
            super.add(value);
            batch(() => {
                this.#triggers.dirty(value);
                this.#triggers.dirty($KEYS);
            });
        }
        return this;
    }
    delete(value) {
        const result = super.delete(value);
        if (result) {
            batch(() => {
                this.#triggers.dirty(value);
                this.#triggers.dirty($KEYS);
            });
        }
        return result;
    }
    clear() {
        if (!super.size)
            return;
        batch(() => {
            this.#triggers.dirty($KEYS);
            for (const member of super.values()) {
                this.#triggers.dirty(member);
            }
            super.clear();
        });
    }
}
/**
 * A reactive version of a Javascript built-in `WeakSet` class.
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/set#ReactiveWeakSet
 * @example
 * const set = new ReactiveWeakSet([1,2,3]);
 * set.has(2) // reactive on change to the result
 * // apply changes
 * set.add(4)
 * set.delete(2)
 */
export class ReactiveWeakSet extends WeakSet {
    #triggers = new TriggerCache(WeakMap);
    constructor(values) {
        super();
        if (values)
            for (const value of values)
                super.add(value);
    }
    has(value) {
        this.#triggers.track(value);
        return super.has(value);
    }
    add(value) {
        if (!super.has(value)) {
            super.add(value);
            this.#triggers.dirty(value);
        }
        return this;
    }
    delete(value) {
        const result = super.delete(value);
        result && this.#triggers.dirty(value);
        return result;
    }
}
/** @deprecated */
export function createSet(initial) {
    const set = new ReactiveSet(initial);
    return new Proxy(() => [...set], {
        get: (_, b) => set[b],
    });
}
/** @deprecated */
export function createWeakSet(initial) {
    return new ReactiveWeakSet(initial);
}
