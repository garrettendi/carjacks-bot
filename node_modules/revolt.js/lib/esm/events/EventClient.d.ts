import { Accessor } from "solid-js";
import EventEmitter from "eventemitter3";
import { Error } from "revolt-api";
import type { AvailableProtocols, EventProtocol } from "./index.js";
/**
 * All possible event client states.
 */
export declare enum ConnectionState {
    Idle = 0,
    Connecting = 1,
    Connected = 2,
    Disconnected = 3
}
/**
 * Event client options object
 */
export interface EventClientOptions {
    /**
     * Whether to log events
     * @default false
     */
    debug: boolean;
    /**
     * Time in seconds between Ping packets sent to the server
     * @default 30
     */
    heartbeatInterval: number;
    /**
     * Maximum time in seconds between Ping and corresponding Pong
     * @default 10
     */
    pongTimeout: number;
    /**
     * Maximum time in seconds between init and first message
     * @default 10
     */
    connectTimeout: number;
}
/**
 * Events provided by the client.
 */
type Events<T extends AvailableProtocols, P extends EventProtocol<T>> = {
    error: (error: Error) => void;
    event: (event: P["server"]) => void;
    state: (state: ConnectionState) => void;
};
/**
 * Simple wrapper around the Revolt websocket service.
 */
export declare class EventClient<T extends AvailableProtocols> extends EventEmitter<Events<T, EventProtocol<T>>> {
    #private;
    readonly options: EventClientOptions;
    readonly ping: Accessor<number>;
    readonly state: Accessor<ConnectionState>;
    /**
     * Create a new event client.
     * @param protocolVersion Target protocol version
     * @param transportFormat Communication format
     * @param options Configuration options
     */
    constructor(protocolVersion: T, transportFormat?: "json", options?: Partial<EventClientOptions>);
    /**
     * Set the current state
     * @param state state
     */
    private setState;
    /**
     * Connect to the websocket service.
     * @param uri WebSocket URI
     * @param token Authentication token
     */
    connect(uri: string, token: string): void;
    /**
     * Disconnect the websocket client.
     */
    disconnect(): void;
    /**
     * Send an event to the server.
     * @param event Event
     */
    send(event: EventProtocol<T>["client"]): void;
    /**
     * Handle events intended for client before passing them along.
     * @param event Event
     */
    handle(event: EventProtocol<T>["server"]): void;
    /**
     * Last error encountered by events client
     */
    get lastError(): {
        type: "socket";
        data: any;
    } | {
        type: "revolt";
        data: ({
            type: "LabelMe";
        } | {
            type: "AlreadyOnboarded";
        } | {
            type: "UsernameTaken";
        } | {
            type: "InvalidUsername";
        } | {
            type: "DiscriminatorChangeRatelimited";
        } | {
            type: "UnknownUser";
        } | {
            type: "AlreadyFriends";
        } | {
            type: "AlreadySentRequest";
        } | {
            type: "Blocked";
        } | {
            type: "BlockedByOther";
        } | {
            type: "NotFriends";
        } | {
            type: "TooManyPendingFriendRequests";
            max: number;
        } | {
            type: "UnknownChannel";
        } | {
            type: "UnknownAttachment";
        } | {
            type: "UnknownMessage";
        } | {
            type: "CannotEditMessage";
        } | {
            type: "CannotJoinCall";
        } | {
            type: "TooManyAttachments";
            max: number;
        } | {
            type: "TooManyEmbeds";
            max: number;
        } | {
            type: "TooManyReplies";
            max: number;
        } | {
            type: "TooManyChannels";
            max: number;
        } | {
            type: "EmptyMessage";
        } | {
            type: "PayloadTooLarge";
        } | {
            type: "CannotRemoveYourself";
        } | {
            type: "GroupTooLarge";
            max: number;
        } | {
            type: "AlreadyInGroup";
        } | {
            type: "NotInGroup";
        } | {
            type: "AlreadyPinned";
        } | {
            type: "NotPinned";
        } | {
            type: "UnknownServer";
        } | {
            type: "InvalidRole";
        } | {
            type: "Banned";
        } | {
            type: "TooManyServers";
            max: number;
        } | {
            type: "TooManyEmoji";
            max: number;
        } | {
            type: "TooManyRoles";
            max: number;
        } | {
            type: "AlreadyInServer";
        } | {
            type: "CannotTimeoutYourself";
        } | {
            type: "ReachedMaximumBots";
        } | {
            type: "IsBot";
        } | {
            type: "BotIsPrivate";
        } | {
            type: "CannotReportYourself";
        } | {
            type: "MissingPermission";
            permission: string;
        } | {
            type: "MissingUserPermission";
            permission: string;
        } | {
            type: "NotElevated";
        } | {
            type: "NotPrivileged";
        } | {
            type: "CannotGiveMissingPermissions";
        } | {
            type: "NotOwner";
        } | {
            type: "DatabaseError";
            operation: string;
            collection: string;
        } | {
            type: "InternalError";
        } | {
            type: "InvalidOperation";
        } | {
            type: "InvalidCredentials";
        } | {
            type: "InvalidProperty";
        } | {
            type: "InvalidSession";
        } | {
            type: "NotAuthenticated";
        } | {
            type: "DuplicateNonce";
        } | {
            type: "NotFound";
        } | {
            type: "NoEffect";
        } | {
            type: "FailedValidation";
            error: string;
        } | {
            type: "ProxyError";
        } | {
            type: "FileTooSmall";
        } | {
            type: "FileTooLarge";
            max: number;
        } | {
            type: "FileTypeNotAllowed";
        } | {
            type: "ImageProcessingFailed";
        } | {
            type: "NoEmbedData";
        } | {
            type: "VosoUnavailable";
        }) & {
            location: string;
        };
    } | undefined;
}
export {};
//# sourceMappingURL=EventClient.d.ts.map