/**
 * Functions to map from one object to another
 */
export type MappingFns<Input, Output, Key extends keyof Output> = Record<Key, (value: Input, context: unknown) => Output[Key]>;
/**
 * Key mapping information
 */
export type KeyMapping<Input, Output> = Record<keyof Input, keyof Output>;
/**
 * Hydration information
 */
export type Hydrate<Input, Output> = {
    keyMapping: Partial<KeyMapping<Input, Output>>;
    functions: MappingFns<Input, Output, keyof Output>;
    initialHydration: () => Partial<Output>;
};
declare const hydrators: {
    bot: Hydrate<{
        _id: string;
        owner: string;
        token: string;
        public: boolean;
        analytics?: boolean;
        discoverable?: boolean;
        interactions_url?: string;
        terms_of_service_url?: string;
        privacy_policy_url?: string;
        flags?: number;
    }, import("./bot.js").HydratedBot>;
    channel: Hydrate<import("../lib/merge.js").Merge<{
        channel_type: "SavedMessages";
        _id: string;
        user: string;
    } | {
        channel_type: "DirectMessage";
        _id: string;
        active: boolean;
        recipients: string[];
        last_message_id?: string | null;
    } | {
        channel_type: "Group";
        _id: string;
        name: string;
        owner: string;
        description?: string | null;
        recipients: string[];
        icon?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        last_message_id?: string | null;
        permissions?: number | null;
        nsfw?: boolean;
    } | {
        channel_type: "TextChannel";
        _id: string;
        server: string;
        name: string;
        description?: string | null;
        icon?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        last_message_id?: string | null;
        default_permissions?: import("revolt-api/lib/schema.js").components["schemas"]["OverrideField"] | null;
        role_permissions?: {
            [key: string]: import("revolt-api/lib/schema.js").components["schemas"]["OverrideField"];
        };
        nsfw?: boolean;
    } | {
        channel_type: "VoiceChannel";
        _id: string;
        server: string;
        name: string;
        description?: string | null;
        icon?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        default_permissions?: import("revolt-api/lib/schema.js").components["schemas"]["OverrideField"] | null;
        role_permissions?: {
            [key: string]: import("revolt-api/lib/schema.js").components["schemas"]["OverrideField"];
        };
        nsfw?: boolean;
    }>, import("./channel.js").HydratedChannel>;
    channelUnread: Hydrate<import("../lib/merge.js").Merge<{
        _id: import("revolt-api/lib/schema.js").components["schemas"]["ChannelCompositeKey"];
        last_id?: string | null;
        mentions?: string[];
    }>, import("./channelUnread.js").HydratedChannelUnread>;
    channelWebhook: Hydrate<import("../lib/merge.js").Merge<{
        id: string;
        name: string;
        avatar?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        creator_id: string;
        channel_id: string;
        permissions: number;
        token?: string | null;
    }>, import("./channelWebhook.js").HydratedChannelWebhook>;
    emoji: Hydrate<import("../lib/merge.js").Merge<{
        _id: string;
        parent: import("revolt-api/lib/schema.js").components["schemas"]["EmojiParent"];
        creator_id: string;
        name: string;
        animated?: boolean;
        nsfw?: boolean;
    }>, import("./emoji.js").HydratedEmoji>;
    message: Hydrate<import("../lib/merge.js").Merge<{
        _id: string;
        nonce?: string | null;
        channel: string;
        author: string;
        user?: import("revolt-api/lib/schema.js").components["schemas"]["User"] | null;
        member?: import("revolt-api/lib/schema.js").components["schemas"]["Member"] | null;
        webhook?: import("revolt-api/lib/schema.js").components["schemas"]["MessageWebhook"] | null;
        content?: string | null;
        system?: import("revolt-api/lib/schema.js").components["schemas"]["SystemMessage"] | null;
        attachments?: import("revolt-api/lib/schema.js").components["schemas"]["File"][] | null;
        edited?: import("revolt-api/lib/schema.js").components["schemas"]["ISO8601 Timestamp"] | null;
        embeds?: import("revolt-api/lib/schema.js").components["schemas"]["Embed"][] | null;
        mentions?: string[] | null;
        role_mentions?: string[] | null;
        replies?: string[] | null;
        reactions?: {
            [key: string]: string[];
        };
        interactions?: import("revolt-api/lib/schema.js").components["schemas"]["Interactions"];
        masquerade?: import("revolt-api/lib/schema.js").components["schemas"]["Masquerade"] | null;
        pinned?: boolean | null;
        flags?: number;
    }>, import("./message.js").HydratedMessage>;
    server: Hydrate<{
        _id: string;
        owner: string;
        name: string;
        description?: string | null;
        channels: string[];
        categories?: import("revolt-api/lib/schema.js").components["schemas"]["Category"][] | null;
        system_messages?: import("revolt-api/lib/schema.js").components["schemas"]["SystemMessageChannels"] | null;
        roles?: {
            [key: string]: import("revolt-api/lib/schema.js").components["schemas"]["Role"];
        };
        default_permissions: number;
        icon?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        banner?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        flags?: number;
        nsfw?: boolean;
        analytics?: boolean;
        discoverable?: boolean;
    }, import("./server.js").HydratedServer>;
    serverMember: Hydrate<import("../lib/merge.js").Merge<{
        _id: import("revolt-api/lib/schema.js").components["schemas"]["MemberCompositeKey"];
        joined_at: import("revolt-api/lib/schema.js").components["schemas"]["ISO8601 Timestamp"];
        nickname?: string | null;
        avatar?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        roles?: string[];
        timeout?: import("revolt-api/lib/schema.js").components["schemas"]["ISO8601 Timestamp"] | null;
    }>, import("./serverMember.js").HydratedServerMember>;
    session: Hydrate<{
        _id: string;
        name: string;
    }, import("./session.js").HydratedSession>;
    user: Hydrate<{
        _id: string;
        username: string;
        discriminator: string;
        display_name?: string | null;
        avatar?: import("revolt-api/lib/schema.js").components["schemas"]["File"] | null;
        relations?: import("revolt-api/lib/schema.js").components["schemas"]["Relationship"][];
        badges?: number;
        status?: import("revolt-api/lib/schema.js").components["schemas"]["UserStatus"] | null;
        flags?: number;
        privileged?: boolean;
        bot?: import("revolt-api/lib/schema.js").components["schemas"]["BotInformation"] | null;
        relationship: import("revolt-api/lib/schema.js").components["schemas"]["RelationshipStatus"];
        online: boolean;
    }, import("./user.js").HydratedUser>;
};
export type Hydrators = typeof hydrators;
type ExtractInput<T> = T extends Hydrate<infer I, any> ? I : never;
type ExtractOutput<T> = T extends Hydrate<any, infer O> ? O : never;
/**
 * Hydrate some input with a given type
 * @param type Type
 * @param input Input Object
 * @param initial Whether this is the initial hydration
 * @returns Hydrated Object
 */
export declare function hydrate<T extends keyof Hydrators>(type: T, input: Partial<ExtractInput<Hydrators[T]>>, context: unknown, initial?: boolean): ExtractOutput<Hydrators[T]>;
export {};
//# sourceMappingURL=index.d.ts.map